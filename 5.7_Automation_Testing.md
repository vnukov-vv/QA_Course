# Основы автоматизации. Unit-тесты на Python

## AAA (Arrange, Act, Assert) паттерн

Если посмотреть на юнит тест, то для большинства можно четко выделить 3 части кода:

**Arrange** (настройка) — в этом блоке кода мы настраиваем тестовое окружение тестируемого юнита;<br>
**Act** — выполнение или вызов тестируемого сценария;<br>
**Assert** — проверка того, что тестируемый вызов ведет себя определенным образом.<br>

Этот паттерн улучшает структуру кода и его читабельность, однако начинать писать тест нужно всегда с элемента **Act**.

Поэтому...

## AAS (Act, Assert, Setup) паттерн

**AAS** — этот тот же **AAA** паттерн, но с измененным порядком частей, отсортированных с учетом **Driven approach** и переименованной **Arrange частью в **Setup**, чтобы отличать их по названию.

> **Driven approach**
> Код, который вы пишите, должен иметь причину своего существования. Важно, чтобы причина была существующей, а не предполагаемой, и эта причина должна иметь в конечном итоге связь с бизнес историей.

- _Первое_, что мы делаем, при создании теста — создаем **Act**. Обычно это создание экземпляра класса тестируемого юнита и вызов его функции (этот шаг диктует нам бизнес история)

- _Второе_ — мы проверяем что **Act** действует ожидаемо и пишем **Assert** часть, где выражаем требуемые последствия **Act**, в том числе с точки зрения бизнес истории.

- _Третье_ — пора задуматься о реализации: как наш юнит будет выполнять требуемые действия и какое runtime окружение ему для этого нужно - **Setup**. <br><br>_Полностью контролируемое окружение_ — это окружение имитирующие среду. Поведение окружения задается для конкретного тестового кейса через лаконичный API и любое поведение вне этого кейса для него не определено.

## [Репозиторий](https://github.com/vnukov-vv/QA_Automation_Testing) для тестов из PyCharm

### Код программы
`Calculator.py`
```python
class Calculator:
    def __init__(self):
        pass

    def add(self, x1, x2):
        return x1 + x2

    def multiply(self, x1, x2):
        return x1 * x2

    def subtract(self, x1, x2):
        return x1 - x2

    def divide(self, x1, x2):
        if x2 != 0:
            return x1 / x2
        else:
            print("На ноль делить нельзя!")

```

### Код автотеста
`TestCase.py`
```python
import unittest

from Calculator import Calculator

class TestCalculator(unittest.TestCase):
    def setUp(self):
        self.calculator = Calculator()
    def test_add(self):
        self.assertEqual(self.calculator.add(4,7), 11)
    def test_multiply(self):
        self.assertEqual(self.calculator.multiply(3, 7), 21)
    def test_subtract(self):
        self.assertEqual(self.calculator.subtract(10,5), 5)
    def test_divide(self):
        self.assertEqual(self.calculator.divide(10,2), 5)
    def test_divnull(self):
        self.assertEqual(self.calculator.divide(10, 0), 5)

if __name__ == "__main__":

unittest.main()
```
